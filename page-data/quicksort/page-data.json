{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/quicksort","result":{"data":{"brainNote":{"slug":"quicksort","title":"Quicksort","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Quicksort\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"#algorithm \"), mdx(\"p\", null, \"Quicksort is a very commonly used sorting algorithm due to its efficiency.\"), mdx(\"p\", null, \"The main idea of the algorithm is: pick a pivot element, then partition the elements of the array into two halves around that pivot, each half will be sorted recursively until everything is sorted.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"./images/quicksort.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"The following algorithm has the best case time complexity of O(n log n) and worst case is O(n^2).\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"int function Partition (Array A, int Lb, int Ub);    \\n  begin                                              \\n  select a pivot from A[Lb]...A[Ub];                 \\n  reorder A[Lb]...A[Ub] such that:                   \\n    all values to the left of the pivot are <= pivot \\n    all values to the right of the pivot are >= pivot\\n  return pivot position;                             \\n  end;                                               \\n                                                     \\nprocedure QuickSort (Array A, int Lb, int Ub);       \\n  begin                                              \\n  if Lb < Ub then                                    \\n    M = Partition (A, Lb, Ub);                       \\n    QuickSort (A, Lb, M - 1);                        \\n    QuickSort (A, M + 1, Ub);                        \\n  end;                                               \\n\")), mdx(\"p\", null, \"About the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"partition\"), \" algorithm, there are two well known schemes:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Lomuto Partition Scheme:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"function partitionLomuto(array, left, right) { \\n  var pivot = right;                           \\n  var i = left;                                \\n  for(var j = left; j < right; j++) {          \\n    if(array[j] <= array[pivot]) {             \\n      swap(array, i , j);                      \\n      i = i + 1;                               \\n    }                                          \\n  }                                            \\n  swap(array, i, j);                           \\n  return i;                                    \\n}                                              \\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Hoare Partition Scheme:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"function partitionHoare(array, left, right) {   \\n  var pivot = Math.floor((left + right) / 2 );  \\n  while(left <= right) {                        \\n    while(array[left] < array[pivot]) {         \\n      left++;                                   \\n    }                                           \\n    while(array[right] > array[pivot]) {        \\n      right--;                                  \\n    }                                           \\n    if(left <= right) {                         \\n      swap(array, left, right);                 \\n      left++;                                   \\n      right--;                                  \\n    }                                           \\n  }                                             \\n  return left;                                  \\n}                                               \\n\")), mdx(\"p\", null, \"For comparision between the two schemes:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Hoare\\u2019s scheme is more efficient than Lomuto\\u2019s partition scheme because it does three times fewer swaps on average, and it creates efficient partitions even when all values are equal.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Like Lomuto\\u2019s partition scheme, Hoare partitioning also causes Quicksort to degrade to O(n^2) when the input array is already sorted, it also doesn\\u2019t produce a stable sort.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Note that in this scheme, the pivot\\u2019s final location is not necessarily at the index that was returned, and the next two segments that the main algorithm recurs on are (lo..p) and (p+1..hi) as opposed to (lo..p-1) and (p+1..hi) as in Lomuto\\u2019s scheme.\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"Home Page","slug":"about","childMdx":{"excerpt":"Welcome! Look like you've found my personal notebook. This is the place where you can take a peek into my mind to see what I've beenâ€¦"}}],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Huy's Notes"}}},"pageContext":{"slug":"quicksort"}},"staticQueryHashes":[]}