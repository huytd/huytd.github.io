{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/threads-in-webassembly","result":{"data":{"brainNote":{"slug":"threads-in-webassembly","title":"Threads in WebAssembly","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Threads in WebAssembly\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"#webassembly \"), mdx(\"p\", null, \"Starting from Chrome 70, there's a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pthread\"), \" support added, you can enable it in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"chrome://flags\"), \" screen. At the time of writing, there's only Chrome that support \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pthread\"), \".\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://developers.google.com/web/updates/images/2018/10/WasmThreads3.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Or using \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developers.chrome.com/origintrials/#/trials/active\"\n  }), \"Origin Trial\"), \" to enable the features right on your user's browser, by a token attached to your domain.\"), mdx(\"h2\", null, \"How to use?\"), mdx(\"p\", null, \"To use, just write your program as normal, then when you compile, supply the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"USE_PTHREADS\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PTHREAD_POOL_SIZE\"), \" into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"emcc\"), \" command:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"emcc -O2 -s USE_PTHREADS=1 -s PTHREAD_POOL_SIZE=2 -o test.js test.c\\n\")), mdx(\"h2\", null, \"Under the hood\"), mdx(\"p\", null, \"Browsers already has support for thread via \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\"\n  }), \"Web Workers\"), \", but they do not share mutable data between them, they relying on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"message passing\"), \" for communication.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Side note:\"), \" Message passing with Web Workers has a big performance impact: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.loxodrome.io/post/web-worker-performance/\"\n  }), \"https://www.loxodrome.io/post/web-worker-performance/\")), mdx(\"p\", null, \"WebAssembly threads can share data between threads, the shared memory implemented using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SharedArrayBuffer\"), \". Each thread in the thread pool runs in a Web Worker. That's why we supply the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PTHREAD_POOL_SIZE\"), \" in the compile step.\"), mdx(\"p\", null, \"Make sure thread pool size is equals to the maximum number of threads your application needs, or thread creation \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"may\"), \" fail. But don't make it too large, you'll create unnecessary Web Workers that do nothing, but still using memory.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Question:\"), \" I heard that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SharedArrayBuffer\"), \" is disabled due to the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://meltdownattack.com/\"\n  }), \"Spectre and Meltdown\"), \", then what will happen to WebAssembly Threads?\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Answer:\"), \" The vulnerabilities will be fixed eventually, then browsers will start shipping with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SharedArrayBuffer\"), \" enabled by default again, everything should be fine. In the meantime, we can just enable it ourselves.\"), mdx(\"hr\", null), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Bonus:\"), \" A great article about how Rust implemented thread support for WebAssembly thru \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wasm-bindgen\"), \", they even have a working demo but there are still so many works to do: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html\"\n  }), \"https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"Home Page","slug":"about","childMdx":{"excerpt":"Welcome! Look like you've found my personal notebook. This is the place where you can take a peek into my mind to see what I've beenâ€¦"}}],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Huy's Notes"}}},"pageContext":{"slug":"threads-in-webassembly"}},"staticQueryHashes":[]}